# Architecture de l'application

## Frontend

### Choix

pour le frontend, le large choix m'a fait me poser beaucoup de questions, entre les frameworks tels que react, angular, vue... et les langages tels que php offrent un choix varié. 

mon choix s'est alors tourné vers les frameworks.

Premièrement ayant pour but de pouvoir utiliser les packages node dont j'ai plus l'habitude de me servir que ceux de composer de php. 

Deuxièmement car je pouvais alors me servir de React, framework que j'ai le plus l'habitude d'utiliser, bien que Angular était un choix pertinent.

j'ai donc fait le choix de React, avec TSX

en ce qui concerne les packages installés, j'ai fait le choix d'utiliser les icônes de Bootstrap, que j'ai utilisé dans le package "react-icons" qui intègre les icônes directement dans des composants, "react-markdown" me permettant d'avoir un composant prenant en paramètre une variable contenant un string, qui le transforme en markdown afin d'afficher les recettes correctement, les packages classiques tels que react-dom, react-router-dom, etc...

### Utilisation

le frontend se compose, excepté pour les écrans de connexion et de création de compte, : 

d'un header dont le contenu diffère en fonction de l'écran, qui accueille notamment le titre de l'écran sur lequel nous nous trouvons, et un bouton retour si nécessaire

du corps de l'écran, qui dépend a 100% de l'écran sélectionné mais qui respecte quand même le style de base de l'application

une bottom bar contenant 5 boutons, servant a naviguer entre les écrans les plus importants tels que :
- **L'écran d'accueil** : contenant la prévisualisation des dernières publications postées de la plus récente a la plus ancienne
- **L'écran de recherche** : contenant une barre de recherche, avec en dessous les résultats, ou un message si le résultat de la recherche est vide
- **L'écran de création** : composé de deux onglets, le premier sert a entrer toutes les informations relatives a la nouvelle recette que l'utilisateur désire poster, et le deuxième onglet servant a prévisualiser sa recette, reprenant exactement le même style que l'écran affiché lors du clic sur une prévisualisation de recette
- **L'écran de compte** : affiche en premier lieu les informations relatives au compte sur lequel nous sommes connectés, tels que le nom d'utilisateur, l'adresse mail ainsi que le nom complet, et en second lieu la prévisualisation des recettes que l'utilisateur a posté dans l'ordre de la plus récente a la plus ancienne
- **L'écran de paramètres** : ne servant pour l'instant qu'à avoir accès a un bouton "Déconnexion"

la bottom bar grise légèrement le bouton correspondant a l'écran sur lequel nous sommes, excepté pour deux écrans, les seuls deux écrans qui ne sont pas accessibles depuis la bottom bar : 
- **L'écran de recette** : affiché après le clic sur une prévisualisation de recette, l'écran est composé d'un bloc d'informations au dessus, contenant les informations : titre, temps de préparation, nombre de personnes ainsi que le nombre de likes, suivi d'un espace ou la recette est renseignée, d'abord une liste d'ingrédients, ensuite le corps de la recette, et juste au dessus de la bottom bar, un autre bloc contenant le nom d'utilisateur de la personne ayant posté la recette, et trois boutons d'action : liker, commenter et enregistrer (malheureusement le bouton enregistrer ne fonctionne pas encore)
- **L'écran de commentaires** : accessible depuis l'écran de recette, il affiche tout les commentaires les uns a la suite des autres, le plus récent en bas, a la manière d'un chat, les commentaires contiennent le nom d'utilisateur de la personne ayant commenté, ainsi que le contenu du commentaire

## Backend

### Choix

le choix pour le backend a été beaucoup plus rapide, étant donné que je n'avais encore jamais fait de backend, mais aussi que le backend n'avais pas besoin de faire beaucoup de traitement, mais seulement servir pour renvoyer les données de la base, mon choix s'est porté sur un backend en node, écrit en js

j'ai utilisé bien sur des packages node tels que express pour la connexion a la base de données, cors afin de cloisonner l'accès (aux requêtes, et donc a la base de données) uniquement a l'adresse ip du vps, ainsi que winston pour me créer un fichier de logs afin de savoir ce qui s'est passé en cas de bugs et autres problèmes remontés par les utilisateurs (même si le back ne considère pas ça comme des erreurs)

### Utilisation

le backend se compose de plusieurs fichiers : 
- **index.js**, contenant tout les chemins d'appel, et faisant la liaison avec les deux fichiers de méthodes
- **PublicationQuerries.js**, contenant toutes les requêtes relatives aux publications tels que les likes, le post, etc
- **UserQuerries.js**, contenant toutes les requêtes relatives aux utilisateurs tels que connexion, création de compte, accès aux informations
- **Logger.js**, contenant les méthodes pour mettre des informations et erreurs dans le fichier de log, avec la date, le nom de la méthode, et si elle a réussi, ou si elle a levé une erreur avec le contenu de l'erreur dans ce cas
- **DateUtils.js** : servant simplement a récupérer la date actuelle ainsi que traiter la donnée reçue pour lui donner ce format : dd-MM-yyyy HH:mm:ss

## Base de données

### Choix

le choix de la base de données était initialement porté sur MySql, car c'était le seul SGBD que j'avais déjà utilisé. cependant, après avoir utilisé PostgreSQL dans le cadre professionnel, et ma base de données n'étant pas encore très imposante, j'ai rapidement changé de SGBD afin de passer sur PostgreSQL, dans le but de m'en servir plus facilement dans le cadre professionnel, mais aussi dans le but de me servir plus que de celui ci dans le reste des projets que j'entreprendrai (tout comme le backend en js, qui après utilisation, correspond totalement a ce dont j'ai besoin)

### Utilisation

la base de données comporte actuellement quatre tables:
- publications
- users
- comments
- publication_likes

___
**Publications** : 

| Colonnes | Type | information |
| --- | --- | --- |
| uuid | uuid | auto générée, not null, clé primaire |
| title | varchar(60) | not null | 
| publication_date | timestamp | auto générée |
| author | varchar(20) | not null |
| likes | int4 | not null | 
| n_personnes | int4 | not null |
| content | text | not null |
| user_id | uuid | foreign key (user.uuid) |

___

**publication_likes** : 

| Colonnes | Type | information |
| --- | --- | --- |
| publication_id | uuid | foreign key (publication.uuid) |
| user_id | uuid | foreign key (user.uuid) |

___

**accounts** : 

| Colonnes | Type | information |
| --- | --- | --- |
| uuid | uuid | auto générée, not null, clé primaire |
| username | varchar(20) | not null | 
| email | varchar(100) | not null | 
| password | varchar(255) | not null | 
| full_name | varchar(100) | not null | 
| created_at | timestamp | auto générée |

___ 

**commentaires** : 

| Colonnes | Type | information |
| --- | --- | --- |
| uuid | uuid | auto générée, not null, clé primaire |
| user_id | uuid | foreign key (user.uuid) |
| publication_id | uuid | foreign key (publication.uuid) |
| date_publication | timestamp |  auto générée |
| contenu | text | not null |

## Hébergement 

### Choix

pour l'Hébergement, j'ai choisi Hostinger, qui va me permettre de gérer a la fois le nom de domaine et le VPS, mais qui va aussi me permettre de créer un sous domaine dédié a mon application, j'avais le choix avec beaucoup d'autres solutions mais Hostinger m'a semblé être un choix judicieux car un ami m'a déjà beaucoup parlé de cette solution qu'il utilise personnellement alors je savais qu'en cas de soucis je pourrais avoir de l'aide, même si je n'en ai pas eu besoin

### Utilisation