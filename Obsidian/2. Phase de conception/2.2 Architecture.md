# Architecture de l'application

## Frontend

### Choix

pour le frontend, le large choix m'a fait me poser beaucoup de questions, entre les frameworks tels que react, angular, vue... et les langages tels que php offrent un choix varié. 

mon choix s'est alors tourné vers les frameworks.

Premièrement ayant pour but de pouvoir utiliser les packages node dont j'ai plus l'habitude de me servir que ceux de composer de php. 

Deuxièmement car je pouvais alors me servir de React, framework que j'ai le plus l'habitude d'utiliser, bien que Angular était un choix pertinent.

j'ai donc fait le choix de React, avec TSX

en ce qui concerne les packages installés, j'ai fait le choix d'utiliser les icônes de Bootstrap, que j'ai utilisé dans le package "react-icons" qui intègre les icônes directement dans des composants, "react-markdown" me permettant d'avoir un composant prenant en paramètre une variable contenant un string, qui le transforme en markdown afin d'afficher les recettes correctement, les packages classiques tels que react-dom, react-router-dom, etc...

### Utilisation

le frontend se compose, excepté pour les écrans de connexion et de création de compte, : 

d'un header dont le contenu diffère en fonction de l'écran, qui accueille notamment le titre de l'écran sur lequel nous nous trouvons, et un bouton retour si nécessaire

du corps de l'écran, qui dépend a 100% de l'écran sélectionné mais qui respecte quand même le style de base de l'application

une bottom bar contenant 5 boutons, servant a naviguer entre les écrans les plus importants tels que :
- **L'écran d'accueil** : contenant la prévisualisation des dernières publications postées de la plus récente a la plus ancienne
- **L'écran de recherche** : contenant une barre de recherche, avec en dessous les résultats, ou un message si le résultat de la recherche est vide
- **L'écran de création** : composé de deux onglets, le premier sert a entrer toutes les informations relatives a la nouvelle recette que l'utilisateur désire poster, et le deuxième onglet servant a prévisualiser sa recette, reprenant exactement le même style que l'écran affiché lors du clic sur une prévisualisation de recette
- **L'écran de compte** : affiche en premier lieu les informations relatives au compte sur lequel nous sommes connectés, tels que le nom d'utilisateur, l'adresse mail ainsi que le nom complet, et en second lieu la prévisualisation des recettes que l'utilisateur a posté dans l'ordre de la plus récente a la plus ancienne
- **L'écran de paramètres** : ne servant pour l'instant qu'à avoir accès a un bouton "Déconnexion"

la bottom bar grise légèrement le bouton correspondant a l'écran sur lequel nous sommes, excepté pour deux écrans, les seuls deux écrans qui ne sont pas accessibles depuis la bottom bar : 
- **L'écran de recette** : affiché après le clic sur une prévisualisation de recette, l'écran est composé d'un bloc d'informations au dessus, contenant les informations : titre, temps de préparation, nombre de personnes ainsi que le nombre de likes, suivi d'un espace ou la recette est renseignée, d'abord une liste d'ingrédients, ensuite le corps de la recette, et juste au dessus de la bottom bar, un autre bloc contenant le nom d'utilisateur de la personne ayant posté la recette, et trois boutons d'action : liker, commenter et enregistrer (malheureusement le bouton enregistrer ne fonctionne pas encore)
- **L'écran de commentaires** : accessible depuis l'écran de recette, il affiche tout les commentaires les uns a la suite des autres, le plus récent en bas, a la manière d'un chat, les commentaires contiennent le nom d'utilisateur de la personne ayant commenté, ainsi que le contenu du commentaire

## Backend

### Choix

le choix pour le backend a été beaucoup plus rapide, étant donné que je n'avais encore jamais fait de backend, mais aussi que le backend n'avais pas besoin de faire beaucoup de traitement, mais seulement servir pour renvoyer les données de la base, mon choix s'est porté sur un backend en node, écrit en js

j'ai utilisé bien sur des packages node tels que express pour la connexion a la base de données, cors afin de cloisonner l'accès (aux requêtes, et donc a la base de données) uniquement a l'adresse ip du vps, ainsi que winston pour me créer un fichier de logs afin de savoir ce qui s'est passé en cas de bugs et autres problèmes remontés par les utilisateurs (même si le back ne considère pas ça comme des erreurs)

### Utilisation

le backend se compose de plusieurs fichiers : 
- **index.js**, contenant tout les chemins d'appel, et faisant la liaison avec les deux fichiers de méthodes
- **PublicationQuerries.js**, contenant toutes les requêtes relatives aux publications tels que les likes, le post, etc
- **UserQuerries.js**, contenant toutes les requêtes relatives aux utilisateurs tels que connexion, création de compte, accès aux informations
- **Logger.js**, contenant les méthodes pour mettre des informations et erreurs dans le fichier de log, avec la date, le nom de la méthode, et si elle a réussi, ou si elle a levé une erreur avec le contenu de l'erreur dans ce cas
- **DateUtils.js** : servant simplement a récupérer la date actuelle ainsi que traiter la donnée reçue pour lui donner ce format : dd-MM-yyyy HH:mm:ss

## Base de données

### Choix

le choix de la base de données était initialement porté sur MySql, car c'était le seul SGBD que j'avais déjà utilisé. cependant, après avoir utilisé PostgreSQL dans le cadre professionnel, et ma base de données n'étant pas encore très imposante, j'ai rapidement changé de SGBD afin de passer sur PostgreSQL, dans le but de m'en servir plus facilement dans le cadre professionnel, mais aussi dans le but de me servir plus que de celui ci dans le reste des projets que j'entreprendrai (tout comme le backend en js, qui après utilisation, correspond totalement a ce dont j'ai besoin)

### Utilisation

la base de données comporte actuellement quatre tables:
- publications
- users
- comments
- publication_likes

___
**Publications** : 

| Colonnes | Type | information |
| --- | --- | --- |
| uuid | uuid | auto générée, not null, clé primaire |
| title | varchar(60) | not null | 
| publication_date | timestamp | auto générée |
| author | varchar(20) | not null |
| likes | int4 | not null | 
| n_personnes | int4 | not null |
| content | text | not null |
| user_id | uuid | foreign key (user.uuid) |

___

**publication_likes** : 

| Colonnes | Type | information |
| --- | --- | --- |
| publication_id | uuid | foreign key (publication.uuid) |
| user_id | uuid | foreign key (user.uuid) |

___

**accounts** : 

| Colonnes | Type | information |
| --- | --- | --- |
| uuid | uuid | auto générée, not null, clé primaire |
| username | varchar(20) | not null | 
| email | varchar(100) | not null | 
| password | varchar(255) | not null | 
| full_name | varchar(100) | not null | 
| created_at | timestamp | auto générée |

___ 

**commentaires** : 

| Colonnes | Type | information |
| --- | --- | --- |
| uuid | uuid | auto générée, not null, clé primaire |
| user_id | uuid | foreign key (user.uuid) |
| publication_id | uuid | foreign key (publication.uuid) |
| date_publication | timestamp |  auto générée |
| contenu | text | not null |

## Hébergement 

### Choix

pour l'Hébergement, j'ai choisi Hostinger, qui va me permettre de gérer a la fois le nom de domaine et le VPS, mais qui va aussi me permettre de créer un sous domaine dédié a mon application, j'avais le choix avec beaucoup d'autres solutions mais Hostinger m'a semblé être un choix judicieux car un ami m'a déjà beaucoup parlé de cette solution qu'il utilise personnellement alors je savais qu'en cas de soucis je pourrais avoir de l'aide, même si je n'en ai pas eu besoin

### Utilisation

Une fois mon compte Hostinger créé et l'achat d'un vps effectué (j'ai pris le moins cher, ayant pas encore besoin de beaucoup de ressources, le premier plan me suffisait amplement), j'ai alors choisi le système d'exploitation, Ubuntu 23.04 64bit sans interface graphique, étant donné que mon vps n'a pas beaucoup de ressources je me suis dit que ça ne servait a rien d'avoir une interface.

Alors, j'ai ajouté les fichiers de mon application, backend et frontend, dans le dossier root afin de lancer les deux. J'ai utilisé screens afin de gérer les deux applications en même temps. 

En ce qui concerne le backend, je l'ai simplement lancé comme je le faisait sur ma machine, en faisant `node index.js`, puis je l'ai laissé tourner dans mon screen.

pour le frontend, j'ai build mon application, et envoyé les fichiers du build dans le dossier /var/www/html.

En ce qui concerne le nom de domaine, j'ai acheté ebasson.fr depuis l'interface de Hostinger, avant de créer un sous domaine pointant sur l'adresse ip du vps que je venais d'installer

Après avoir lié mon nom de domaine a mon vps, j'ai suivi un tutoriel pour installer et utiliser correctement Nginx afin qu'il redirige tout trafic http du port 80 vers les fichiers de mon application, dans le dossier /var/www/html

j'ai ensuite automatisé grâce a une fonction .bashrc afin de récupérer automatiquement le dernier commit, et refaire toute la séquence afin de mettre a jour l'application, ce qui me permet de faire des mises a jour et correctifs très rapidement après les retours des premiers utilisateurs

en ce qui concerne la base de données, j'ai installé PostgreSQL sur la machine et configuré correctement le fichier ph_hba.conf pour autoriser mon adresse ip personnelle a accéder aux bases, afin de me connecter avec dbeaver, rendant les évolutions sur la base de données aussi simple que la mise a jour de l'application de production